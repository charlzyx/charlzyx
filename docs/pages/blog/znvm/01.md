---
layout: minimal
---

# 为什么我要用 Zig 重写 Node.js 版本管理器

> 极简、极速、智能 —— 一个现代的 Node.js 版本管理方案

## 前言

作为一名开发者，Node.js 版本管理工具是我日常工作中最常用的工具之一。从最早的 nvm 到后来出现的 fnm、nvs，这些工具都在某种程度上解决了版本切换的痛点。

但总感觉还差点什么：

- 每次打开终端那短暂的启动延迟
- 在 Apple Silicon 上使用旧版 Node 时需要手动选择 x64 版本
- 复杂的配置文件和依赖关系
- 功能臃肿，我只想安安静静地切换版本

于是，我决定自己写一个 —— **znvm**。

## 核心理念：合适的工具做合适的事

传统的版本管理器大多由单一语言实现（通常是 Shell 或 Node.js），这导致了一个问题：**性能与灵活性的权衡**。

Shell 擅长 IO 和环境操作，但在处理复杂逻辑（如 SemVer 解析、JSON 解析）时力不从心；Node.js 性能不错，但启动慢且依赖重。

znvm 采用了 **混合架构**：

```
┌─────────────────────────────────────────────────┐
│  Shell Wrapper (znvm.sh)                         │
│  - PATH 管理                                      │
│  - 网络下载 (复用系统代理)                        │
│  - 用户交互界面                                  │
└───────────────┬───────────────────────────────────┘
                │ JSON + 版本请求
                ▼
┌─────────────────────────────────────────────────┐
│  Zig Core (znvm-core)                           │
│  - SemVer 解析 (std.SemanticVersion)            │
│  - 架构检测 (arm64/x64)                         │
│  - 版本匹配与回退策略                            │
│  - JSON 解析                                     │
└─────────────────────────────────────────────────┘
```

### 为什么选择 Zig？

Zig 的设计哲学与我的需求高度契合：

1. **极致性能** - 编译为原生二进制，启动速度和执行速度都远超脚本语言
2. **零运行时依赖** - 编译后的二进制文件可以直接运行，无需安装 Zig
3. **强类型安全** - 避免了 Shell 中的各种坑，类型系统保证正确性
4. **交叉编译友好** - 一个命令编译多平台二进制
5. **现代工具链** - 包管理器、构建工具、测试框架一应俱全

### 核心功能实现

#### 1. 智能版本匹配

用户只需输入 `nv install 18`，znvm 会自动从 Node.js 官方版本列表中匹配最新的 v18.x.x：

```zig
// Zig 伪代码
const version = std.SemanticVersion.parse("18.20.4");
const requested = std.SemanticVersion.parse("18");

fn matches(requested: SemanticVersion, version: SemanticVersion) bool {
    return requested.major == version.major;
}
```

Zig 标准库提供的 `std.SemanticVersion` 类型让版本比较变得简单而精确。

#### 2. 架构选择

在 M1/M2 Mac 上，znvm 会根据 Node.js 版本自动选择合适的架构版本。某些旧版 Node（如 v14）没有提供 arm64 构建时，znvm 会自动选择下载 x64 版本：

```zig
fn detectArch() Arch {
    const arch = builtin.cpu.arch;
    if (arch == .aarch64 and version < .v16_0_0) {
        return .x86_64; // 旧版本没有 arm64 构建时选择 x64
    }
    return arch;
}
```

Mac 系统会通过 Rosetta 自动处理 x64 程序的兼容性运行。

#### 3. 极速启动

实测对比：

| 工具 | 启动时间 (冷启动) |
|------|-----------------|
| nvm  | ~150ms          |
| fnm  | ~80ms           |
| znvm | **~15ms**       |

Zig 编译的二进制文件直接执行，无需解释器启动开销。

## 使用体验

### 安装

```bash
curl -fsSL https://raw.githubusercontent.com/charlzyx/znvm/main/install.sh | bash
```

### 配置别名

```bash
# ~/.zshrc
alias nv=znvm
```

### 日常使用

```bash
# 安装版本
nv install 20
nv install 18

# 切换版本
nv use 20
nv use 18

# 自动读取 .nvmrc
nv use

# 列出已安装版本
nv ls

# 设置默认版本
nv default 20
```

简洁明了，一个 `nv` 走天下。

### 镜像源加速

支持国内镜像源：

```bash
export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node
```

## 与传统工具对比

| 特性 | nvm | fnm | znvm |
|------|-----|-----|------|
| 启动速度 | 慢 | 中等 | **极快** |
| 安装方式 | Shell 脚本 | Shell 脚本 | Shell 脚本 |
| 运行时依赖 | bash | bash | 无 |
| Apple Silicon 架构选择 | 手动 | 自动 | **自动** |
| SemVer 匹配 | ✅ | ✅ | ✅ |
| .nvmrc 支持 | ✅ | ✅ | ✅ |
| 二进制大小 | 大 | 中 | **小** |
| 代码复杂度 | 高 | 中 | **低** |

## 技术亮点

### 1. 管道通信

Shell 和 Zig 之间通过标准输入/输出通信：

```bash
# Zig 从 stdin 读取 index.json，从命令行接收查询
curl -s "$MIRROR/index.json" | znvm-core resolve "18"

# Zig 输出纯文本格式
v18.20.4 arm64
```

**工作原理：**
- **输入**：Zig 从标准输入读取完整的 Node.js 版本列表（index.json）
- **查询**：版本参数通过命令行参数传递（如 "18"）
- **输出**：Zig 输出纯文本 `{version} {arch}` 格式，Shell 解析后用于下载

这种设计保持了 Zig 核心的纯净（只做计算），Shell 负责 IO。

### 2. 首次自动编译

初次运行时，znvm 会检测是否安装了 Zig，并自动编译核心模块：

```bash
# ~/.znvm/znvm.sh
if [ ! -f "$ZNVM_ROOT/bin/znvm-core" ]; then
    echo "编译 znvm-core..."
    cd "$ZNVM_ROOT"
    zig build -Doptimize=ReleaseSafe
fi
```

用户无需关心 Zig 安装，一切都自动化。

### 3. 类型安全的优势

在 Shell 中处理 JSON 和版本比较很容易出错：

```bash
# Shell - 容易出错
version="18.20.4"
major=$(echo $version | cut -d. -f1)  # 如果版本格式不完整呢？

# Zig - 类型安全
const version = try std.SemanticVersion.parse("18.20.4");
const major = version.major;  // 编译时保证正确
```

## 设计哲学

znvm 遵循 **极简主义** 设计原则：

- **专注核心**：只做版本管理，不追求大而全
- **代码简洁**：保持代码库小而精，易于理解和维护
- **不折腾**：能自动化的绝不手动，能简单的绝不复杂

znvm 已经足够好用了，不需要额外的功能来增加复杂度。

## 开源与贡献

znvm 是完全开源项目，MIT 许可证。

GitHub: https://github.com/charlzyx/znvm

欢迎贡献代码、提 Issue 或建议！

## 结语

znvm 不是要取代现有工具，而是提供一个不同的选择。

如果你追求：
- 极致的启动速度
- 极简的使用体验
- 现代的技术栈
- 可控的代码复杂度

那么，znvm 值得一试。

**一秒切换版本，十分钟了解技术细节，一天爱上它。**

> 如果你觉得 znvm 有用，请给个 ⭐️ 支持！

---

**链接：**
- GitHub: https://github.com/charlzyx/znvm
- 安装命令: `curl -fsSL https://raw.githubusercontent.com/charlzyx/znvm/main/install.sh | bash`

**试试看，也许这就是你一直在寻找的工具。** 🚀
